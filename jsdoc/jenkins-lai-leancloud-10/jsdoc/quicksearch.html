<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" LeanCloud Server Global calculateAgeGroupcalculateHoroscope Global Methods calculateAgeGroup(birthdate) Convert birthday to age group. Parameters: Name Type Description birthdate string The date of birth. Returns: The corresponding AgeGroup. Type number | AgeGroup calculateHoroscope(birthdate) Convert birthday to horoscope. Parameters: Name Type Description birthdate string The date of birth. Returns: The corresponding Horoscope. Type number | Horoscope × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" LeanCloud Server Global calculateAgeGroupcalculateHoroscope LeanCloud-serverServer code written for LeanCloud based on the so called cloud code 3.0. Folder Structure&lt;&lt;Root of the project&gt;&gt; | config &lt;&lt;Configurations&gt;&gt; | dist &lt;&lt;Transpiled server code that is going to be deployed&gt;&gt; | jsdoc &lt;&lt;Documentation&gt;&gt; | node_modules | populator &lt;&lt;Populate database with production data&gt;&gt; | scripts &lt;&lt;Scripts for the project&gt;&gt; | server | | └── cloud &lt;&lt;Cloud code&gt;&gt; | | | ├── cloudfunction &lt;&lt;Custom cloud functions&gt;&gt; | | | ├── controller &lt;&lt;Per class callbacks&gt;&gt; | | | └── utility &lt;&lt;Utilities for cloud code&gt;&gt; | test | ├── fixture &lt;&lt;Mock data shared among all tests&gt;&gt; | ├── helper &lt;&lt;Mocha test helpers&gt;&gt; | ├── unit &lt;&lt;Unit tests&gt;&gt; | ├── integration &lt;&lt;Integration tests&gt;&gt; | ├── generative &lt;&lt;Generative tests&gt;&gt; | └── system &lt;&lt;System tests&gt;&gt; | .arcconfig &lt;&lt;Arcanist configuration&gt;&gt; DO NOT TOUCH | .arclint &lt;&lt;Arcanist configuration&gt;&gt; DO NOT TOUCH | .babelrc &lt;&lt;Babel configuration&gt;&gt; DO NOT TOUCH | .eslintignore &lt;&lt;ESLint ignore&gt;&gt; DO NOT TOUCH | .eslintrc &lt;&lt;ESLint rules&gt;&gt; DO NOT TOUCH | .gitignore &lt;&lt;Git ignore&gt;&gt; DO NOT TOUCH | .nvmrc &lt;&lt;NVM configuration&gt;&gt; DO NOT TOUCH | .travis.yml &lt;&lt;Travis configuration&gt;&gt; DO NOT TOUCH | app.js &lt;&lt;Load and configure server components&gt;&gt; | cloud.js &lt;&lt;Configure cloud code&gt;&gt; | gulpfile.babel.js &lt;&lt;Gulp tasks&gt;&gt; DO NOT TOUCH | jsdoc.conf.json &lt;&lt;JSDoc configuration&gt;&gt; | package.json &lt;&lt;Node.js package.json&gt;&gt; DO NOT TOUCH unless you know what you are doing | README.md &lt;&lt;This file&gt;&gt; └── server.js &lt;&lt;Starting point of server&gt;&gt;Getting started Install nvm and node.js version 0.12.7. The version node.js run on Leancloud is so far based on 0.12.x. Local development and testing environment should match the production environment. Enter nvm use 0.12.7 in command line. Install [^avoscloud-code-command]: avoscloud-code-command command line tool Clone the repo Run npm install in command line. Setup schema, indexing, CLP (class level permission) and ACL (access control list)All database setting files are located in populator/database_settings. Schema Database schema has to be setup manually. The easiest way is to import the schema to the database via the web interface. Go to the web interface of your database instance on LeanCloud. Under &quot;存储&quot;, click on the gears icon on the right side of &quot;数据&quot;. On the menu, click &quot;数据导入&quot;. On the popup, under &quot;导入 class&quot; enter the name of the class and select the schema file. For example, to import the _User schema, enter _User as the class name and select the file at populator/database_setings/_User/_User.schema.json. Import schemas for all classes found in populator/database_settings. Indexing Once you've finished importing schema, go back to the same &quot;存储&quot; page. Click on a class you just imported schema for. Then click on &quot;其他 =&gt; 索引&quot;. In the popup, setup the indexing exactly like the documentation for each class. You can find the documentation under populator/database_settings for each class. Note that some of the indexes are required and filled by LeanCloud. Just make sure your version looks exactly the same as the documentation. CLP TBD ACL TBD Populate DatabaseThere are two ways to populate the database: Run the populator script using the following command: npm run populate -- -i &lt;&lt;APP_ID&gt;&gt; -k &lt;&lt;APP_KEY&gt;&gt; -m &lt;&lt;MASTER_KEY&gt;&gt; Manually import population. Method 2 is the recommended way, as the population script can hit the database several thousand times. And if network is congested, some operation could be lost. Go to the web interface of your database instance on LeanCloud. Under &quot;存储&quot;, click on the gears icon on the right side of &quot;数据&quot;. On the menu, click &quot;数据导入&quot;. On the popup, under &quot;导入 class&quot; enter the name of the class and select the schema file. For example, to import the L_Region schema, enter L_Region as the class name and select the file at populator/database_setings/L_Region/L_Region.population.json. Import population for all classes found in populator/database_settings, if applicable. Setup private configGo to config/ directory. Create a file named cookie.js. The content of the file is as below:module.exports = { secret: &lt;&lt;your cookie secret&gt;&gt; };In command enter python scripts/generate_secret.py | pbcopy. Make sure you have python installed. This script will generate a random cookie secret and copy it to your clipboard. Replace the placeholder in cookie.js with the generated secret by pasting. Create a file named secret.js. The content of the file is as below: module.exports = { development: { }, test: { APP_ID: &lt;&lt;ID&gt;&gt; APP_KEY: &lt;&lt;KEY&gt;&gt;, MASTER_KEY: &lt;&lt;MASTER_KEY&gt;&gt; }, production: { APP_ID: &lt;&lt;ID&gt;&gt;, APP_KEY: &lt;&lt;KEY&gt;&gt;, MASTER_KEY: &lt;&lt;MASTER_KEY&gt;&gt; } };Replace the placeholders with the keys from LeanCloud. Note that development, test, and production each refers to a different environment. They can have different keys. Test code is configured to run against the test environment. Deploy to your LeanCloud database instance for the first timeBefore you start this section, there's one thing you have to keep in mind. The server code is written in es6 and transpile via babel. The transpliation step is necessary because, as of now, LeanCloud still runs on v0.12.x of Node,js, which does not support most es6 features. Before the code can be deployed to LeanCloud, it has to be transpiled, locally, to es5. Although it is possible to use babel to transpile the code right as node server starts, this significantly increases the duration of deployment. This is due to the time it takes to download babel and transpile the code. Consequently the server code is transpiled to dist directly. From there the code is deployed to a LeanCloud instance. It takes about one minute to deploy. Go to LeanCloud and log in. Create a new instance of database. Note down the name. Go to the setting page of that database and look for appID and masterKey. You will need both of these. At root directory of the repo, enter avoscloud add &lt;name of database instance&gt; &lt;appID&gt; -f dist using the information acquired. This is going to create and save info in dist/.avoscloud directory. If you entered info wrong, manually delete the folder. Once you are ready to push the code to the database instance, enter npm run deploy:avos in short in command line. Note that the command line tool will ask you for masterKey the first time its run. For more info on how the command line works, refer to [^avoscloud-code-command]: avoscloud-code-command. The command-line tool will compress the project and upload it to the instance you have specified on LeanCloud. The tool will print out a series of log in the command-line. npm run deploy:avos will deploy the code to test environment. You can target the test environment specifically when initializing the client. However, to deploy to production environment, you have to run npm run publish:avos in command-line. Note that you cannot directly push local code to production. It has to go through test environment first. That being said, production environment deployment takes significantly less time to complete. Debug and testingDue to restrictions inherent to BaaS platform, debugging cloud code is not as straightforward as that for custom server stack. Specifically, you do not have complete control of the environment. Some compromises have to be made during testing. That being said there are definitely tools to go around the problems. Individually debug and test cloud hooks and cloud functionsCloud code 3.0 allows developers to, partially, test server code on local machine. Check whether the command-line tool, avoscloud-code-command, is installed before proceeding. To launched the server locally, at command line enter avoscloud. If it asks for app ID and master key, find out on leancloud's website. A local debug web page can be reached at debug page. On that page, you can individually select cloud hooks and cloud functions, and manually enter JSON data to debug. For example, to test a cloud function, you'd select the function from the dropdown menu, then enter data in JSON format in the textbox. Run the command and the webpage will return result. This also works for cloud hooks. PROS: Test cloud hooks and cloud functions in isolation. For example, testing beforeUpdate will not trigger afterUpdate. Faster feedback. No need to deploy to LeanCloud. CONS: Manually craft JSON data can be tedious very soon. The local server is a mock server. Hence there's no guaruntee it functions exactly the same as production environment. Tests can be written against cloud hooks and functions individually on the local moc server. Conceptually the tests behave similarly to the debug page. You'd craft JSON request in code and send it to local mock server. Take a look at the code in test/ingegration. superagent is used to handle raw JSON network request. NOTE: Make sure you enter nvm use to switch to the correct Node.js version. To run integration test: gulp test:int. To run integration test on file change: gulp test:w. System level debug and testNow the above method is only good for testing hooks and functions in isolation. However, it does not guaruntee that they'd work correctly together in production. For example, a request coming in to update a User record will always trigger beforeUpdate and afterUpdate. And if code in beforeUpdate also saves data in another table, it will trigger another set of hooks. In addition, the table schema also comes into effect. There's a similar, above mentioned, debug page for system level debug. Click on &quot;帮助&quot; on the top menu bar. In the dropdown menu click on &quot;在线API测试工具&quot;. This is very similar to the local debug page. NOTE you have publish server code to production environment in order to use this tool. To do that first deploy to test environment , npm run deploy:avos, then publish to production, npm run publish:avos. In system tests we utilize avoscloud-sdk to test againt the entire system. In essence we are basically simulating how clients would interact with server. Take a look at the code in test/system for examples. PROS: High level of confidence in correctness. Basically running tests against production environment. CONS: Have to deploy before running tests. Have to do it every time there's changes in server code. Takes about 1 minute to deploy. To use the online debug page, have to publish code. Tests take longer to run due to network travel time. Harder to write tests as a lot of factors, such as database schema, ACL, CLP, etc, come into play. Of course you have to deploy the server code to LeanCloud before running system test. The system tests environment has been configured to hit test environment only, so you don't have to publish to production environment each time. To deploy: npm run deploy:avos. To run system test: gulp test:sys. To run system test on file change: gulp test:w. The above two methods compliment each other. Debug and testing cloud hooks and function individually allows developers to iterate faster, and it ensures correctness on a unit level. However, individually working components do not guarantee that they work correctly together. That is why a system level test is also important. The downside however is that system test is usually slow to run. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
